# typings/js.pyi (completo para Pyodide)
from typing import Any, Callable, Generic, Iterable, Optional, Sequence, Union, TypeVar


T = TypeVar('T')



class Node(EventTarget, JSObject):
    # Propriedades e métodos comuns a todos os nós
    parentNode: Optional['Node']
    childNodes: Sequence['Node']
    firstChild: Optional['Node']
    lastChild: Optional['Node']
    nextSibling: Optional['Node']
    previousSibling: Optional['Node']
    textContent: Optional[str]
    
    def appendChild(self, child: 'Node') -> 'Node': ...
    def removeChild(self, child: 'Node') -> 'Node': ...
    def insertBefore(self, newChild: 'Node', refChild: Optional['Node'] = ...) -> 'Node': ...
    def replaceChild(self, newChild: 'Node', oldChild: 'Node') -> 'Node': ...
    def cloneNode(self, deep: bool = ...) -> 'Node': ...
    def contains(self, other: 'Node') -> bool: ...


class Element(Node):
    # Propriedades e métodos específicos de elementos
    tagName: str
    id: str
    className: str
    classList: 'DOMTokenList'
    namespaceURI: str
    prefix: str
    localName: str
    scrollLeft: int
    scrollTop: int
    scrollWidth: int
    scrollHeight: int
    clientLeft: int
    clientTop: int
    def requestFullscreen(self, options: dict = ...) -> Promise: ...


class JSFunction:
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def new(string: str) -> 'JSFunction': ...
    def bind(self, this: Any, *args: Any) -> 'JSFunction': ...
    def apply(self, this: Any, args: Sequence[Any]) -> Any: ...
    @property
    def name(self) -> str: ...

Function = JSFunction


class JSObject:
    def __getattr__(self, name: str) -> Any: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getitem__(self, key: Union[int, str]) -> Any: ...
    def __setitem__(self, key: Union[int, str], value: Any) -> None: ...
    def __delitem__(self, key: Union[int, str]) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __contains__(self, key: Union[int, str]) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterable[Any]: ...



Object = JSObject


class Console(JSObject):
    def log(self, *args: Any) -> None: ...
    def error(self, *args: Any) -> None: ...
    def warn(self, *args: Any) -> None: ...
    def info(self, *args: Any) -> None: ...
    def debug(self, *args: Any) -> None: ...
    def table(self, data: Any, columns: Optional[Sequence[str]] = ...) -> None: ...
    def time(self, label: str = ...) -> None: ...
    def timeEnd(self, label: str = ...) -> None: ...
    def trace(self, *args: Any) -> None: ...
    def group(self, *args: Any) -> None: ...
    def groupEnd(self) -> None: ...


class PointerEvent(JSObject):
    # Propriedades
    AT_TARGET: int
    BUBBLING_PHASE: int
    CAPTURING_PHASE: int
    NONE: int
    altKey: bool
    altitudeAngle: float
    azimuthAngle: float
    bubbles: bool
    button: int
    buttons: int
    cancelBubble: bool
    cancelable: bool
    clientX: int
    clientY: int
    composed: bool
    ctrlKey: bool
    currentTarget: Any
    defaultPrevented: bool
    detail: int
    eventPhase: int
    fromElement: Any
    isPrimary: bool
    isTrusted: bool
    js_id: Any
    layerX: int
    layerY: int
    metaKey: bool
    movementX: int
    movementY: int
    offsetX: int
    offsetY: int
    pageX: int
    pageY: int
    persistentDeviceId: int
    pointerId: int
    pointerType: str
    pressure: float
    relatedTarget: Any
    returnValue: Any
    screenX: int
    screenY: int
    shiftKey: bool
    sourceCapabilities: Any
    srcElement: Any
    tangentialPressure: float
    target: Any
    tiltX: float
    tiltY: float
    timeStamp: float
    toElement: Any
    twist: float
    type: str
    view: Any
    which: int
    width: int
    x: int
    y: int

    # Métodos
    def getCoalescedEvents(self) -> list['PointerEvent']: ...
    def getModifierState(self, keyArg: str) -> bool: ...
    def getPredictedEvents(self) -> list['PointerEvent']: ...
    def initEvent(self, typeArg: str, canBubbleArg: bool, cancelableArg: bool) -> None: ...
    def initMouseEvent(self, typeArg: str, canBubbleArg: bool, cancelableArg: bool, viewArg: Any,
                       detailArg: int, screenXArg: int, screenYArg: int, clientXArg: int, clientYArg: int,
                       ctrlKeyArg: bool, altKeyArg: bool, shiftKeyArg: bool, metaKeyArg: bool,
                       buttonArg: int, relatedTargetArg: Any) -> None: ...
    def initUIEvent(self, typeArg: str, canBubbleArg: bool, cancelableArg: bool, viewArg: Any,
                    detailArg: int) -> None: ...
    def preventDefault(self) -> None: ...
    def stopImmediatePropagation(self) -> None: ...
    def stopPropagation(self) -> None: ...


class Document(Node, JSObject):
    # Propriedades
    body: 'HTMLElement'
    head: 'HTMLElement'
    title: str
    cookie: str
    readyState: str
    referrer: str
    location: 'Location'
    defaultView: 'Window'
    activeElement: 'HTMLElement'
    
    # Métodos
    def getElementById(self, id: str) -> Optional['HTMLElement']: ...
    def createElement(self, tagName: str) -> 'HTMLElement': ...
    def createTextNode(self, data: str) -> 'Text': ...
    def querySelector(self, selectors: str) -> Optional['HTMLElement']: ...
    def querySelectorAll(self, selectors: str) -> Sequence['HTMLElement']: ...
    def getElementsByClassName(self, classNames: str) -> Sequence['HTMLElement']: ...
    def getElementsByTagName(self, tagName: str) -> Sequence['HTMLElement']: ...
    def getElementsByName(self, name: str) -> Sequence['HTMLElement']: ...
    def createEvent(self, eventType: str) -> 'Event': ...
    def addEventListener(self, event: str, handler: JSFunction, options: Any = ...) -> None: ...
    def removeEventListener(self, event: str, handler: JSFunction, options: Any = ...) -> None: ...


class Navigator(JSObject):
    # Propriedades
    userAgent: str
    platform: str
    language: str
    languages: list[str]
    cookieEnabled: bool
    hardwareConcurrency: int
    maxTouchPoints: int
    
    # Métodos
    def javaEnabled(self) -> bool: ...
    def vibrate(self, pattern: Union[int, Sequence[int]]) -> bool: ...


class Location(JSObject):
    # Propriedades
    href: str
    protocol: str
    host: str
    hostname: str
    port: str
    pathname: str
    search: str
    hash: str
    origin: str
    
    # Métodos
    def reload(self, forceReload: bool = ...) -> None: ...
    def replace(self, url: str) -> None: ...
    def assign(self, url: str) -> None: ...


class History(JSObject):
    # Propriedades
    length: int
    state: Any
    
    # Métodos
    def back(self) -> None: ...
    def forward(self) -> None: ...
    def go(self, delta: int) -> None: ...
    def pushState(self, state: Any, title: str, url: Optional[str]) -> None: ...
    def replaceState(self, state: Any, title: str, url: Optional[str]) -> None: ...


class Storage(JSObject):
    # Propriedades
    length: int
    
    # Métodos
    def getItem(self, key: str) -> Optional[str]: ...
    def setItem(self, key: str, value: str) -> None: ...
    def removeItem(self, key: str) -> None: ...
    def clear(self) -> None: ...
    def key(self, index: int) -> Optional[str]: ...


class Event(JSObject):
    # Propriedades
    type: str
    target: JSObject
    currentTarget: JSObject
    bubbles: bool
    cancelable: bool
    defaultPrevented: bool
    eventPhase: int
    timeStamp: float
    isTrusted: bool
    composed: bool
    
    # Métodos
    def preventDefault(self) -> None: ...
    def stopPropagation(self) -> None: ...
    def stopImmediatePropagation(self) -> None: ...
    def composedPath(self) -> list[JSObject]: ...


class EventTarget(JSObject):
    def addEventListener(self, event: str, handler: JSFunction, options: Union[bool, dict] = ...) -> None: ...
    def removeEventListener(self, event: str, handler: JSFunction, options: Union[bool, dict] = ...) -> None: ...
    def dispatchEvent(self, event: Event) -> bool: ...


class Text(Node, JSObject):
    data: str
    wholeText: str
    def splitText(self, offset: int) -> 'Text': ...


class HTMLElement(Element, EventTarget, JSObject):
    # Propriedades
    id: str
    className: str
    classList: 'DOMTokenList'
    style: 'CSSStyleDeclaration'
    innerHTML: str
    outerHTML: str
    innerText: str
    textContent: str
    children: Sequence['HTMLElement']
    firstChild: 'HTMLElement'
    lastChild: 'HTMLElement'
    parentElement: Optional['HTMLElement']
    parentNode: Optional['HTMLElement']
    nextSibling: Optional['HTMLElement']
    previousSibling: Optional['HTMLElement']
    tagName: str
    dataset: dict[str, str]
    hidden: bool
    tabIndex: int
    title: str
    offsetWidth: int
    offsetHeight: int
    clientWidth: int
    clientHeight: int
    scrollWidth: int
    scrollHeight: int
    scrollLeft: int
    scrollTop: int
    
    # Métodos
    def connectedCallback(self) -> None: ...
    def disconnectedCallback(self) -> None: ...
    def adoptedCallback(self) -> None: ...
    def attributeChangedCallback(self, name: str, oldValue: Any, newValue: Any) -> None: ...
    def click(self) -> None: ...
    def focus(self) -> None: ...
    def blur(self) -> None: ...
    def scrollIntoView(self, alignToTop: Union[bool, dict] = ...) -> None: ...
    def getBoundingClientRect(self) -> 'DOMRect': ...
    def getAttribute(self, name: str) -> Optional[str]: ...
    def setAttribute(self, name: str, value: str) -> None: ...
    def removeAttribute(self, name: str) -> None: ...
    def hasAttribute(self, name: str) -> bool: ...
    def appendChild(self, child: 'Node') -> 'Node': ...
    def removeChild(self, child: 'Node') -> 'Node': ...
    def insertBefore(self, newChild: 'Node', refChild: Optional['Node'] = ...) -> 'Node': ...
    def replaceChild(self, newChild: 'Node', oldChild: 'Node') -> 'Node': ...
    def cloneNode(self, deep: bool = ...) -> 'Node': ...
    def contains(self, other: 'Node') -> bool: ...
    def matches(self, selector: str) -> bool: ...
    def closest(self, selector: str) -> Optional['Node']: ...
    def getElementsByClassName(self, classNames: str) -> Sequence['Node']: ...
    def getElementsByTagName(self, tagName: str) -> Sequence['Node']: ...
    def querySelector(self, selector: str) -> Optional['Node']: ...
    def querySelectorAll(self, selector: str) -> Sequence['Node']: ...
    def addEventListener(self, event: str, handler: JSFunction, options: Any = ...) -> None: ...
    def removeEventListener(self, event: str, handler: JSFunction, options: Any = ...) -> None: ...
    def attachShadow(self, init: dict) -> 'ShadowRoot': ...


class DOMTokenList(JSObject):
    length: int
    value: str
    def add(self, *tokens: str) -> None: ...
    def remove(self, *tokens: str) -> None: ...
    def contains(self, token: str) -> bool: ...
    def toggle(self, token: str, force: bool = ...) -> bool: ...
    def replace(self, oldToken: str, newToken: str) -> None: ...
    def item(self, index: int) -> Optional[str]: ...


class CSSStyleDeclaration(JSObject):
    cssText: str
    length: int
    def getPropertyValue(self, prop: str) -> str: ...
    def setProperty(self, prop: str, value: str, priority: str = ...) -> None: ...
    def removeProperty(self, prop: str) -> str: ...
    def item(self, index: int) -> str: ...


class DOMRect(JSObject):
    x: float
    y: float
    width: float
    height: float
    top: float
    right: float
    bottom: float
    left: float


class ShadowRoot(HTMLElement):
    mode: str
    host: HTMLElement


class Promise(JSObject, Generic[T]):
    def then(self, on_fulfilled: Optional[Callable[[Any], Any]] = ..., 
             on_rejected: Optional[Callable[[Any], Any]] = ...) -> "Promise": ...
    def catch(self, on_rejected: Callable[[Any], Any]) -> "Promise": ...
    def finally_(self, on_finally: Callable[[], Any]) -> "Promise": ...


# def fetch(input: Union[str, JSObject], init: Optional[JSObject] = ...) -> Promise: ...


class TimerHandle(JSObject):
    pass



class XMLHttpRequest(EventTarget):
    # Propriedades
    readyState: int
    response: Any
    responseText: str
    responseType: str
    responseURL: str
    responseXML: Optional[Document]
    status: int
    statusText: str
    timeout: int
    upload: Any
    withCredentials: bool
    
    # Constantes
    UNSENT: int
    OPENED: int
    HEADERS_RECEIVED: int
    LOADING: int
    DONE: int
    
    # Métodos
    def open(self, method: str, url: str, _async: bool = ..., user: str = ..., password: str = ...) -> None: ...
    def send(self, data: Any = ...) -> None: ...
    def abort(self) -> None: ...
    def setRequestHeader(self, name: str, value: str) -> None: ...
    def getResponseHeader(self, name: str) -> Optional[str]: ...
    def getAllResponseHeaders(self) -> str: ...
    def overrideMimeType(self, mime: str) -> None: ...


class URLSearchParams(JSObject):
    def __init__(self, init: Union[str, dict, list] = ...) -> None: ...
    def append(self, name: str, value: str) -> None: ...
    def delete(self, name: str) -> None: ...
    def get(self, name: str) -> Optional[str]: ...
    def getAll(self, name: str) -> list[str]: ...
    def has(self, name: str) -> bool: ...
    def set(self, name: str, value: str) -> None: ...
    def sort(self) -> None: ...
    def entries(self) -> Iterable[tuple[str, str]]: ...
    def keys(self) -> Iterable[str]: ...
    def values(self) -> Iterable[str]: ...
    def __str__(self) -> str: ...


class URL(JSObject):
    href: str
    origin: str
    protocol: str
    username: str
    password: str
    host: str
    hostname: str
    port: str
    pathname: str
    search: str
    searchParams: URLSearchParams
    hash: str
    def __init__(self, url: str, base: Optional[str] = ...) -> None: ...
    def toJSON(self) -> str: ...


class Blob(JSObject):
    size: int
    type: str
    def arrayBuffer(self) -> Promise: ...
    def text(self) -> Promise: ...
    def slice(self, start: int = ..., end: int = ..., contentType: str = ...) -> 'Blob': ...


class File(Blob):
    name: str
    lastModified: int
    webkitRelativePath: str


class FormData(JSObject):
    def append(self, name: str, value: Union[str, Blob], filename: str = ...) -> None: ...
    def delete(self, name: str) -> None: ...
    def get(self, name: str) -> Optional[Union[str, File]]: ...
    def getAll(self, name: str) -> list[Union[str, File]]: ...
    def has(self, name: str) -> bool: ...
    def set(self, name: str, value: Union[str, Blob], filename: str = ...) -> None: ...
    def entries(self) -> Iterable[tuple[str, Union[str, File]]]: ...
    def keys(self) -> Iterable[str]: ...
    def values(self) -> Iterable[Union[str, File]]: ...


class Response(JSObject):
    headers: 'Headers'
    ok: bool
    redirected: bool
    status: int
    statusText: str
    type: str
    url: str
    body: Any
    bodyUsed: bool
    def arrayBuffer(self) -> Promise: ...
    def blob(self) -> Promise[Blob]: ...
    def formData(self) -> Promise[FormData]: ...
    def json(self) -> Promise[Any]: ...
    def text(self) -> Promise[str]: ...
    def clone(self) -> 'Response': ...


class Headers(JSObject):
    def __init__(self, init: Optional[Union[dict, Sequence[Sequence[str]]]] = ...) -> None: ...
    def append(self, name: str, value: str) -> None: ...
    def delete(self, name: str) -> None: ...
    def get(self, name: str) -> Optional[str]: ...
    def has(self, name: str) -> bool: ...
    def set(self, name: str, value: str) -> None: ...
    def entries(self) -> Iterable[tuple[str, str]]: ...
    def keys(self) -> Iterable[str]: ...
    def values(self) -> Iterable[str]: ...


class Request(Response):
    method: str
    url: str
    headers: Headers
    destination: str
    referrer: str
    referrerPolicy: str
    mode: str
    credentials: str
    cache: str
    redirect: str
    integrity: str
    keepalive: bool
    isReloadNavigation: bool
    isHistoryNavigation: bool
    signal: Any
    def __init__(self, input: Union[str, Request], init: dict = ...) -> None: ...
    def clone(self) -> 'Request': ...


class CustomElementRegistry(JSObject):
    def define(self, name: str, constructor: Any, options: dict = ...) -> None: ...
    def get(self, name: str) -> Any: ...
    def whenDefined(self, name: str) -> Promise: ...


class Window(EventTarget, JSObject):
    # Propriedades
    document: Document
    navigator: Navigator
    location: Location
    history: History
    console: Console
    localStorage: Storage
    sessionStorage: Storage
    customElements: CustomElementRegistry
    performance: 'Performance'
    screen: 'Screen'
    devicePixelRatio: float
    innerWidth: int
    innerHeight: int
    outerWidth: int
    outerHeight: int
    pageXOffset: int
    pageYOffset: int
    scrollX: int
    scrollY: int
    parent: 'Window'
    top: 'Window'
    frameElement: Element
    name: str
    closed: bool
    length: int
    opener: Any
    crypto: 'Crypto'
    
    # Métodos
    def alert(self, message: str) -> None: ...
    def confirm(self, message: str) -> bool: ...
    def prompt(self, message: str, default_value: Optional[str] = None) -> Optional[str]: ...
    def open(self, url: str, target: str = "_blank", features: str = "") -> Optional['Window']: ...
    def close(self) -> None: ...
    def stop(self) -> None: ...
    def focus(self) -> None: ...
    def blur(self) -> None: ...
    def scroll(self, x: int, y: int) -> None: ...
    def scrollTo(self, x: int, y: int) -> None: ...
    def scrollBy(self, x: int, y: int) -> None: ...
    def postMessage(self, message: Any, targetOrigin: str, transfer: Sequence[Any] = ...) -> None: ...
    def requestAnimationFrame(self, callback: Callable[[float], None]) -> int: ...
    def cancelAnimationFrame(self, handle: int) -> None: ...
    def matchMedia(self, query: str) -> 'MediaQueryList': ...
    def getComputedStyle(self, element: Element, pseudoElt: Optional[str] = ...) -> CSSStyleDeclaration: ...
    def btoa(self, data: str) -> str: ...
    def atob(self, data: str) -> str: ...
    def setTimeout(self, handler: Union[JSFunction, Callable[..., Any]], timeout: int = 0, *args: Any) -> TimerHandle: ...
    def clearTimeout(self, handle: TimerHandle) -> None: ...
    def setInterval(self, handler: Union[JSFunction, Callable[..., Any]], timeout: int = 0, *args: Any) -> TimerHandle: ...
    def clearInterval(self, handle: TimerHandle) -> None: ...


class Screen(JSObject):
    width: int
    height: int
    availWidth: int
    availHeight: int
    colorDepth: int
    pixelDepth: int
    orientation: dict


class Performance(JSObject):
    timing: dict
    def now(self) -> float: ...
    def getEntries(self) -> list[dict]: ...


class Crypto(JSObject):
    subtle: 'SubtleCrypto'
    def getRandomValues(self, array: Union['Int8Array', 'Uint8Array', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array']) -> Any: ...


class SubtleCrypto(JSObject):
    def encrypt(self, algorithm: Any, key: Any, data: Any) -> Promise: ...
    # ... (outros métodos de criptografia)


class Int8Array(JSObject): ...
class Uint8Array(JSObject): ...
class Int16Array(JSObject): ...
class Uint16Array(JSObject): ...
class Int32Array(JSObject): ...
class Uint32Array(JSObject): ...
class Float32Array(JSObject): ...
class Float64Array(JSObject): ...


class MediaQueryList(JSObject):
    media: str
    matches: bool
    onchange: Optional[Callable[..., Any]]
    def addListener(self, listener: Callable[..., Any]) -> None: ...
    def removeListener(self, listener: Callable[..., Any]) -> None: ...


# Funções de temporizador
def setTimeout(handler: Union[JSFunction, Callable[..., Any]], timeout: int = 0, *args: Any) -> TimerHandle: ...
def clearTimeout(handle: TimerHandle) -> None: ...
def setInterval(handler: Union[JSFunction, Callable[..., Any]], timeout: int = 0, *args: Any) -> TimerHandle: ...
def clearInterval(handle: TimerHandle) -> None: ...
def requestAnimationFrame(callback: Callable[[float], None]) -> int: ...
def cancelAnimationFrame(handle: int) -> None: ...


# Funções de codificação
def btoa(data: str) -> str: ...
def atob(data: str) -> str: ...


# Objetos globais
document: Document
console: Console
navigator: Navigator
localStorage: Storage
sessionStorage: Storage
location: Location
history: History
window: Window
customElements: CustomElementRegistry
caches: 'CacheStorage'
performance: Performance
screen: Screen
crypto: Crypto
fetch: Callable[[Union[str, Request], dict], Promise[Response]]


class Cache(JSObject):
    def match(self, request: Union[str, Request], options: dict = ...) -> Promise[Optional[Response]]: ...
    def add(self, request: Union[str, Request]) -> Promise: ...
    def put(self, request: Union[str, Request], response: Response) -> Promise: ...
    def delete(self, request: Union[str, Request], options: dict = ...) -> Promise[bool]: ...


class CacheStorage(JSObject):
    def open(self, cacheName: str) -> Promise[Cache]: ...
    def has(self, cacheName: str) -> Promise[bool]: ...
    def delete(self, cacheName: str) -> Promise[bool]: ...
    def keys(self) -> Promise[list[str]]: ...
    def match(self, request: Union[str, Request], options: dict = ...) -> Promise[Optional[Response]]: ...